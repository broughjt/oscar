from __future__ import annotations
from collections.abc import Iterator
from dataclasses import dataclass
from itertools import product
from sympy import Expr, Symbol, Integer, reduced, symbols, groebner
from typing import Callable

EClassId = Symbol

@dataclass(frozen=True)
class Term:
    operator: str
    operands: tuple[Term]

@dataclass(frozen=True)
class ENode:
    operator: str
    # Tuples are hashable, lists are not
    operands: tuple[EClassId]

# In bottom up e-matching land, a pattern is a function from a tuple
# of variables to both a left and right side? Weird. We also need to
# keep track of how many variables the function has so that we can use
# this information during e-matching. Ideally, we would use the type
# $\Sigma_{n \in \mathbb{N}} Vector(EClassId, n) \to Term \times
# Term$, but basically no programming languages in wide-spread use let
# you do that
RuleFunction = Callable[[EClassId, ...], tuple[Term, Term]]
Rule = tuple[int, RuleFunction]

@dataclass
class EGraph:
    basis: list[Expr]
    classes: list[EClassId]
    hash_cons: dict[ENode, EClassId]

    def __init__(self):
        self.basis = list()
        self.classes = list()
        self.hash_cons = dict()

    def find(self, a: EClassId) -> EClassId:
        # Perform polynomial division in $n$ variables, returns the
        # quotients and the remainder. For some reason this is called
        # `reduced` and not `divide` or something.
        #
        # We're taking the remainder because we consider two eclasses
        # the same when they are equal in the ring $R/I$, where $I$ is
        # the ideal generated by the polynomials in `basis`, and (for
        # now) $R$ is $\mathbb{Z}$. same remainder on division by
        # these polynomials.
        Q, r = reduced(a, self.basis, self.classes)
        return r

    def canonicalize(self, n: Enode) -> ENode:
        return ENode(n.operator, tuple((self.find(a) for a in n.operands)))

    def add(self, n: ENode, hash_cons=True) -> EClassId:
        # TODO: When we canonicalize, it seems like we can't add more
        # than one thing at a time without things breaking with
        # `find`? I still can't think properly about what exactly is
        # going on, but Buddo doesn't canonicalize. Very confused but
        # this needs to be understood cause everything could actually
        # just be broken
        #
        # n = # self.canonicalize(n)
        if n in self.hash_cons and hash_cons:
            a = self.find(self.hash_cons[n])
        else:
            k = len(self.classes)
            a = symbols(f"e{k}")
            self.classes.append(a)
            self.hash_cons[n] = a

            # Okay, now some weird shit
            match n:
                case ENode("+", [b, c]):
                    self.basis.append(a - (b + c))
                case ENode("-", [b]):
                    self.basis.append(a - (-b))
                case ENode("-", [b, c]):
                    self.basis.append(a - (b - c))
                case ENode("*", [b, c]):
                    self.basis.append(a - (b * c))
                case ENode(int() as b, []):
                    self.basis.append(a - Integer(b))

        return a

    def add_term(self, t: Term) -> EClassId:
        return self.add(ENode(
            t.operator,
            tuple((self.add_term(s) for s in t.operands))
        ))

    # Also allow e-class ids which have been substituted for pattern
    # variables
    def add_pattern(self, t: Term | EClassId, hash_cons=True) -> EClassId:
        match t:
            case Symbol():
                # TODO: Call find on this?
                if hash_cons:
                    return self.find(t)
                else:
                    return t
            case Term():
                return self.add(
                    ENode(
                        t.operator,
                        tuple((self.add_pattern(s, hash_cons=hash_cons) for s in t.operands)),
                    ),
                    hash_cons=hash_cons
                )

    def union(self, a: EClassId, b: EClassId, hash_cons=True) -> EClassId:
        if hash_cons:
            a = self.find(a)
            b = self.find(b)
            if a != b:
                self.basis.append(a - b)
        else:
            self.basis.append(a - b)
                

        # TODO: No worklist here? We just rebuild everthing on every
        # rebuild?

    def rebuild(self):
        i = 0
        while True:
            print(i)
            # Rebuild the union find
            self.basis = list(groebner(self.basis, *self.classes))
            print("computed basis", len(self.basis))

            # Fix the hash-cons
            hash_cons = dict()
            for n, a in self.hash_cons.items():
                print(n, a)
                n = self.canonicalize(n)
                print("canonicalize")
                if b := self.hash_cons.get(n):
                    self.union(a, b)
                    print("union")
                hash_cons[n] = self.find(a)
                print("find")

            if self.hash_cons == hash_cons:
                break
            else:
                self.hash_cons = hash_cons

            i += 1

                
    def ematch(self, n: int, p: Rule) -> Iterator[tuple[Term, Term]]:
        # Brute force bottom up e-matching:
        # Q: What matches the pattern?
        # A: Everything?
        return (p(*bs) for bs in product(self.classes, repeat=n))

        
